import { BigNumberish, BytesLike, Provider, Signer } from "ethers";
import { NetworkConfig } from "./networks";
export type RandomnessVerificationParameters = {
    requestID: bigint;
    nonce: bigint;
    randomness: BytesLike;
    signature: BytesLike;
};
export type RandomnessVerificationConfig = {
    shouldBlowUp: boolean;
};
type RequestRandomnessParams = {
    callbackGasLimit: bigint;
    timeoutMs: number;
    confirmations: number;
    pollingIntervalMs: number;
};
export declare class Randomness {
    private readonly rpc;
    private readonly networkConfig;
    private readonly contract;
    private readonly defaultRequestParams;
    constructor(rpc: Signer | Provider, networkConfig: NetworkConfig, defaultRequestTimeoutMs?: number);
    static createFromChainId(rpc: Signer | Provider, chainId: BigNumberish): Randomness;
    requestRandomness(config?: Partial<RequestRandomnessParams>): Promise<RandomnessVerificationParameters>;
    verify(parameters: RandomnessVerificationParameters, config?: RandomnessVerificationConfig): Promise<boolean>;
    /**
     * Calculates the request price for a blocklock request given the callbackGasLimit.
     * @param callbackGasLimit The callbackGasLimit to use when fulfilling the request with a decryption key.
     * @returns The estimated request price and the transaction gas price used
     */
    calculateRequestPriceNative(callbackGasLimit: bigint): Promise<[bigint, bigint]>;
    static createFilecoinMainnet(rpc: Signer | Provider): Randomness;
    static createFilecoinCalibnet(rpc: Signer | Provider): Randomness;
    static createBaseSepolia(rpc: Signer | Provider): Randomness;
    static createPolygonPos(rpc: Signer | Provider): Randomness;
    static createAvalancheCChain(rpc: Signer | Provider): Randomness;
    static createOptimismSepolia(rpc: Signer | Provider): Randomness;
    static createArbitrumSepolia(rpc: Signer | Provider): Randomness;
    static createSeiTestnet(rpc: Signer | Provider): Randomness;
}
export {};
