import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedListener, TypedContractMethod } from "./common";
export declare namespace TypesLib {
    type SignatureRequestStruct = {
        message: BytesLike;
        messageHash: BytesLike;
        condition: BytesLike;
        schemeID: string;
        callback: AddressLike;
        signature: BytesLike;
        isFulfilled: boolean;
    };
    type SignatureRequestStructOutput = [
        message: string,
        messageHash: string,
        condition: string,
        schemeID: string,
        callback: string,
        signature: string,
        isFulfilled: boolean
    ] & {
        message: string;
        messageHash: string;
        condition: string;
        schemeID: string;
        callback: string;
        signature: string;
        isFulfilled: boolean;
    };
}
export interface ISignatureSenderInterface extends Interface {
    getFunction(nameOrSignature: "fulfillSignatureRequest" | "getAllErroredRequestIds" | "getAllFulfilledRequestIds" | "getAllUnfulfilledRequestIds" | "getCountOfUnfulfilledRequestIds" | "getRequest" | "hasErrored" | "isInFlight" | "requestSignature" | "setSignatureSchemeAddressProvider" | "signatureSchemeAddressProvider" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "fulfillSignatureRequest", values: [BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "getAllErroredRequestIds", values?: undefined): string;
    encodeFunctionData(functionFragment: "getAllFulfilledRequestIds", values?: undefined): string;
    encodeFunctionData(functionFragment: "getAllUnfulfilledRequestIds", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCountOfUnfulfilledRequestIds", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRequest", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "hasErrored", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "isInFlight", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "requestSignature", values: [string, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: "setSignatureSchemeAddressProvider", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "signatureSchemeAddressProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "fulfillSignatureRequest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAllErroredRequestIds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAllFulfilledRequestIds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAllUnfulfilledRequestIds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCountOfUnfulfilledRequestIds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRequest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasErrored", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isInFlight", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "requestSignature", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSignatureSchemeAddressProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "signatureSchemeAddressProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
}
export interface ISignatureSender extends BaseContract {
    connect(runner?: ContractRunner | null): ISignatureSender;
    waitForDeployment(): Promise<this>;
    interface: ISignatureSenderInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    fulfillSignatureRequest: TypedContractMethod<[
        requestID: BigNumberish,
        signature: BytesLike
    ], [
        void
    ], "nonpayable">;
    getAllErroredRequestIds: TypedContractMethod<[], [bigint[]], "view">;
    getAllFulfilledRequestIds: TypedContractMethod<[], [bigint[]], "view">;
    getAllUnfulfilledRequestIds: TypedContractMethod<[], [bigint[]], "view">;
    getCountOfUnfulfilledRequestIds: TypedContractMethod<[], [bigint], "view">;
    getRequest: TypedContractMethod<[
        requestID: BigNumberish
    ], [
        TypesLib.SignatureRequestStructOutput
    ], "view">;
    hasErrored: TypedContractMethod<[requestID: BigNumberish], [boolean], "view">;
    isInFlight: TypedContractMethod<[requestID: BigNumberish], [boolean], "view">;
    requestSignature: TypedContractMethod<[
        schemeID: string,
        message: BytesLike,
        condition: BytesLike
    ], [
        bigint
    ], "nonpayable">;
    setSignatureSchemeAddressProvider: TypedContractMethod<[
        newSignatureSchemeAddressProvider: AddressLike
    ], [
        void
    ], "nonpayable">;
    signatureSchemeAddressProvider: TypedContractMethod<[], [string], "view">;
    version: TypedContractMethod<[], [string], "view">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "fulfillSignatureRequest"): TypedContractMethod<[
        requestID: BigNumberish,
        signature: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "getAllErroredRequestIds"): TypedContractMethod<[], [bigint[]], "view">;
    getFunction(nameOrSignature: "getAllFulfilledRequestIds"): TypedContractMethod<[], [bigint[]], "view">;
    getFunction(nameOrSignature: "getAllUnfulfilledRequestIds"): TypedContractMethod<[], [bigint[]], "view">;
    getFunction(nameOrSignature: "getCountOfUnfulfilledRequestIds"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "getRequest"): TypedContractMethod<[
        requestID: BigNumberish
    ], [
        TypesLib.SignatureRequestStructOutput
    ], "view">;
    getFunction(nameOrSignature: "hasErrored"): TypedContractMethod<[requestID: BigNumberish], [boolean], "view">;
    getFunction(nameOrSignature: "isInFlight"): TypedContractMethod<[requestID: BigNumberish], [boolean], "view">;
    getFunction(nameOrSignature: "requestSignature"): TypedContractMethod<[
        schemeID: string,
        message: BytesLike,
        condition: BytesLike
    ], [
        bigint
    ], "nonpayable">;
    getFunction(nameOrSignature: "setSignatureSchemeAddressProvider"): TypedContractMethod<[
        newSignatureSchemeAddressProvider: AddressLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "signatureSchemeAddressProvider"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "version"): TypedContractMethod<[], [string], "view">;
    filters: {};
}
